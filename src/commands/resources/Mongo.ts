/* eslint-disable no-param-reassign */
import { PromptQuestion } from "@src/types/prompt";
import {
  Resource,
  ResourceItemConfigEnv,
  ResourceItemManagementType,
  ResourceType,
} from "@src/types/resource";
import Logger from "@src/utils/Logger";
import Prompt from "@src/utils/Prompt";
import Storage from "@src/utils/Storage";
import { SchemaMap, ValidationOperator } from "@src/utils/Validator";
import env from "../env";

const MONGO_PUBLIC_KEY = "mongo_public_key";
const MONGO_PRIVATE_KEY = "mongo_private_key";
const MONGO_ORG_ID = "mongo_org_id";

export interface MongoInputVariables {
  hostname: string;
  port: number;
  initdbRootUsername: string;
  initdbRootPassword: string;
  publicKey: string;
  privateKey: string;
  orgId: string;
}

const MONGO_INPUT_VARIABLE_KEYS: Array<keyof MongoInputVariables> = [
  "hostname",
  "port",
  "initdbRootUsername",
  "initdbRootPassword",
  "publicKey",
  "privateKey",
  "orgId",
];

type Q = PromptQuestion<MongoInputVariables>;
type Qs = Array<Q>;

class Mongo implements Resource<MongoInputVariables> {
  name = ResourceType.mongo;

  logger = new Logger();

  private prompt = new Prompt();

  private secureStorage = new Storage("secrets");

  private appStorage = new Storage("app");

  buildInputVariableKeys: Array<keyof MongoInputVariables> = [
    "initdbRootUsername",
    "initdbRootPassword",
  ];

  async getInputVariables(
    envConfig: ResourceItemConfigEnv,
    variables: Record<string, unknown> = {},
    filterFxn: ((item: Q, i: number) => boolean) | undefined = undefined,
  ): Promise<MongoInputVariables> {
    try {
      let questions: Qs = [
        {
          type: "list",
          name: "hostname",
          message: "Hostname:",
          choices: ["localhost"],
          default: variables.MONGO_HOSTNAME,
        },
        {
          type: "number",
          name: "port",
          message: "Port:",
          default: variables.MONGO_PORT || 27017,
          validate: (value) =>
            this.prompt.validations.required(value, "Please enter port"),
        },
        {
          type: "input",
          name: "initdbRootUsername",
          message: "Mongo Username:",
          // default will be autogenerated
          default: variables.MONGO_INITDB_ROOT_USERNAME || "root",
          validate: (value) =>
            this.prompt.validations.required(value, "Please enter username"),
        },
        {
          type: "input",
          name: "initdbRootPassword",
          message: "Mongo Password:",
          // default will be autogenerated
          default: variables.MONGO_INITDB_ROOT_PASSWORD || "password",
          validate: (value) =>
            this.prompt.validations.required(value, "Please enter password"),
        },
      ];

      if (
        envConfig.staging === ResourceItemManagementType.managed ||
        envConfig.production === ResourceItemManagementType.managed
      ) {
        questions.push({
          type: "password",
          name: "privateKey",
          message: "Private Key:",
          default:
            variables.MONGO_PRIVATE_KEY ||
            this.secureStorage.get(MONGO_PRIVATE_KEY),
          validate: (value) =>
            this.prompt.validations.required(
              value,
              "Please enter a private key",
            ),
        });
        questions.push({
          type: "password",
          name: "publicKey",
          message: "Public Key:",
          default:
            variables.MONGO_PUBLIC_KEY ||
            this.secureStorage.get(MONGO_PUBLIC_KEY),
          validate: (value) =>
            this.prompt.validations.required(
              value,
              "Please enter a public key",
            ),
        });
        questions.push({
          type: "input",
          name: "orgId",
          message: "Organization Id:",
          default:
            variables.MONGO_ORG_ID || this.secureStorage.get(MONGO_ORG_ID),
          validate: (value) =>
            this.prompt.validations.required(
              value,
              "Please enter Organization Id",
            ),
        });
      }

      if (filterFxn) {
        questions = questions.filter(filterFxn);
      }

      const answers = await this.prompt.ask(questions);
      // Save private and public keys to secrets
      return Promise.resolve(answers);
    } catch (error) {
      return Promise.reject(error);
    }
  }

  get envSchemaMap() {
    return MONGO_INPUT_VARIABLE_KEYS.reduce<SchemaMap>((schema, key) => {
      const envKey = env.getKey(this.name, key);

      switch (key) {
        case "orgId":
        case "privateKey":
        case "publicKey":
          schema[envKey] = ValidationOperator.string().when(
            "$resources.mongo.env.staging",
            {
              is: ResourceItemManagementType.managed,
              then: ValidationOperator.required(),
              otherwise: ValidationOperator.string().when(
                "$resources.mongo.env.production",
                {
                  is: ResourceItemManagementType.managed,
                  then: ValidationOperator.required(),
                  otherwise: ValidationOperator.optional(),
                },
              ),
            },
          );
          break;

        case "port":
          schema[envKey] = ValidationOperator.number().required();
          break;

        default:
          schema[envKey] = ValidationOperator.string().required();
          break;
      }

      return schema;
    }, {});
  }
}

export default Mongo;
