/* eslint-disable no-param-reassign */
import { PromptQuestion } from "@src/types/prompt";
import {
  Resource,
  ResourceItemConfigEnv,
  ResourceItemManagementType,
  ResourceType,
} from "@src/types/resource";
import Logger from "@src/utils/Logger";
import Prompt from "@src/utils/Prompt";
import Storage from "@src/utils/Storage";
import { SchemaMap, ValidationOperator } from "@src/utils/Validator";
import { AppConfig } from "@src/types/config";
import env from "../env";

const MONGO_PUBLIC_KEY = "MONGO_PUBLIC_KEY";
const MONGO_PRIVATE_KEY = "MONGO_PRIVATE_KEY";

export interface MongoInputVariables {
  hostname: string;
  port: number;
  initdbRootUsername: string;
  initdbRootPassword: string;
  publicKey: string;
  privateKey: string;
  orgId: string;
}

const MONGO_INPUT_VARIABLE_KEYS: Array<keyof MongoInputVariables> = [
  "hostname",
  "port",
  "initdbRootUsername",
  "initdbRootPassword",
  "publicKey",
  "privateKey",
  "orgId",
];

type Q = PromptQuestion<MongoInputVariables>;
type Qs = Array<Q>;

class Mongo implements Resource<MongoInputVariables> {
  name = ResourceType.mongo;

  logger = new Logger();

  private prompt = new Prompt();

  private secureStorage = new Storage("secrets");

  private appStorage = new Storage("app");

  buildInputVariableKeys: Array<keyof MongoInputVariables> = [
    "initdbRootUsername",
    "initdbRootPassword",
  ];

  async getInputVariables(
    envConfig: ResourceItemConfigEnv,
    variables: Record<string, unknown> = {},
    filterFxn: ((item: Q, i: number) => boolean) | undefined = undefined,
  ): Promise<{ answers: Partial<MongoInputVariables>; inSync: boolean }> {
    try {
      let questions: Qs = [
        {
          type: "list",
          name: "hostname",
          message: "Hostname:",
          choices: ["localhost"],
          default: variables.MONGO_HOSTNAME,
        },
        {
          type: "number",
          name: "port",
          message: "Port:",
          default: variables.MONGO_PORT || 27017,
          validate: (value) =>
            this.prompt.validations.required(value, "Please enter port"),
        },
        {
          type: "input",
          name: "initdbRootUsername",
          message: "Mongo Username:",
          // default will be autogenerated
          default: variables.MONGO_INITDB_ROOT_USERNAME || "root",
          validate: (value) =>
            this.prompt.validations.required(value, "Please enter username"),
        },
        {
          type: "input",
          name: "initdbRootPassword",
          message: "Mongo Password:",
          // default will be autogenerated
          default: variables.MONGO_INITDB_ROOT_PASSWORD || "password",
          validate: (value) =>
            this.prompt.validations.required(value, "Please enter password"),
        },
      ];

      if (
        envConfig.staging === ResourceItemManagementType.managed ||
        envConfig.production === ResourceItemManagementType.managed
      ) {
        questions.push({
          type: "password",
          name: "privateKey",
          message: "Private Key:",
          default: variables[MONGO_PRIVATE_KEY],
          validate: (value) =>
            this.prompt.validations.required(
              value,
              "Please enter a private key",
            ),
        });
        questions.push({
          type: "password",
          name: "publicKey",
          message: "Public Key:",
          default: variables[MONGO_PUBLIC_KEY],
          validate: (value) =>
            this.prompt.validations.required(
              value,
              "Please enter a public key",
            ),
        });
        questions.push({
          type: "input",
          name: "orgId",
          message: "Organization Id:",
          default: variables.MONGO_ORG_ID,
          validate: (value) =>
            this.prompt.validations.required(
              value,
              "Please enter Organization Id",
            ),
        });
      }

      if (filterFxn) {
        questions = questions.filter(filterFxn);
      }
      const answers = await this.prompt.ask(questions);
      const inSync = Object.keys(answers).length === 0;

      // Save private and public keys to secrets
      if (answers.publicKey) {
        this.secureStorage.set(MONGO_PUBLIC_KEY, answers.publicKey);
        delete answers.publicKey;
      }
      if (answers.privateKey) {
        this.secureStorage.set(MONGO_PRIVATE_KEY, answers.privateKey);
        delete answers.privateKey;
      }

      return Promise.resolve({ answers, inSync });
    } catch (error) {
      return Promise.reject(error);
    }
  }

  getEnvSchemaMap(config: AppConfig) {
    return MONGO_INPUT_VARIABLE_KEYS.reduce<SchemaMap>((schema, key) => {
      const envKey = env.getKey(this.name, key);
      const { production, staging } = config.resources[this.name]!.env;
      const isManaged =
        production === ResourceItemManagementType.managed ||
        staging === ResourceItemManagementType.managed;

      switch (key) {
        case "orgId":
        case "privateKey":
        case "publicKey":
          schema[envKey] = isManaged
            ? ValidationOperator.string().required()
            : ValidationOperator.string().optional();
          break;

        case "port":
          schema[envKey] = ValidationOperator.number().required();
          break;

        default:
          schema[envKey] = ValidationOperator.string().required();
          break;
      }

      return schema;
    }, {});
  }
}

export default Mongo;
